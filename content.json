{"pages":[{"title":"GC's Garbage Collector","text":"Hi, my name is George I´m striving to become a System Architect Loves everything related to Java My Skills JavaScript VanillaJS ES6 TypeScript Angular Tests Jasmine Selenium JUnit Mockito Tooling Webpack Maven Java OO Servlet/JSP Spring Boot CI/CD Jenkins Gitlab Github Actions Docker Kubernetes Main projects Schedule Manager A backend microservice used to manage schedules The objective is to manage all kinds of scheduled tasks","link":"/index.html"},{"title":"關於我","text":"學經歷 大學主修外文，英文為主，日文為輔 碩士主修經濟，擅長個體經濟、計量經濟 半路出家的 Java Programmer 目前為 Full Stack Engineer(自稱) 技術專長Dev(後端) Java SE 的基本 API(OCPJP 7) Spring Framework(Core/Boot/…etc.) MySQL、MSSQL、postgreSQL REDIS MongoDB RabbitMQ、Apache Kafka Dev(前端) Vanilla JS Angular Kendo UI Ops Jenkins 建立完整的 CI/CD 流程 從 commit 到 deploy 均不需額外的功 Docker 將舊系統容器化，建立一致的 Tomcat/Spring boot 用 Dockerfile 建立一致的 docker-compose.yml Kubernetes 建立從 ingress 到 deployment 的 YAML 檔 善用 fast storage/configmap/secret 搭配 Spring Cloud Configuration 中央管理設定檔 透過 Fluentd + Elasticsearch 中央管理日誌","link":"/about/index.html"}],"posts":[{"title":"【深入淺出 Docker(1)】 - Docker 命名由來","text":"平常大家都聽到或稱呼 Docker 習慣了，但您是否知道它的命名由來呢？我相信每一個產品的命名都有它一定的淵源，無論其命名是市場導向，或別有用途，了解它的命名，或許對整體概念能有多一些認識。 歷史 在古早時代，每一種貨物都有其不同的打包方式。亦或是針對它內容物的性質不同，需要特別的環境安置之… 然而在碼頭不可能針對每一項貨物都出專用的工具，或是配置特別的環境處理某些類型的貨物，於是…有人就想出了貨櫃這個打包方式！ 只要你的貨進了貨櫃，那在碼頭的工作人員就不必擔心如何將貨物放置至船上，只要考慮每一個貨櫃的配重即可。 即使是那些需要特殊環境的貨物，只要放進特殊環境的貨櫃即可，再也不用在船上特別提供環境~ 比擬 Docker 與 Container 這個命名的由來，是根據「貨物」透過「貨櫃」的統一置放方式而來 Container 本身除了在 Linux OS 是一個 Process 之外，也暗喻我們所開發的 Application 是以一個「打包好的形式」被部署在各個環境中。 也正因如此， Docker 的 Logo 是隻鯨魚上面載著許多貨櫃，就好比是應用程式被以統一包裝方式(container) 被部署。 小結 不知看了這篇，是否對 docker 本身又更興趣多了點？ 其實容器不只 docker 一種，詳細的以後再寫一篇來談","link":"/2022/01/30/%E3%80%90%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BA%20Docker(1)%E3%80%91%20-%20Docker%20%E5%91%BD%E5%90%8D%E7%94%B1%E4%BE%86/"},{"title":"【深入淺出 Docker(4)】 - docker commit","text":"除了前篇稍微提到的 Dockerfile，還有一種方式可以建立 image如果只是想快速建立一個 snapshot 性質的 image，又不想撰寫完整的 Dockerfile，可以參考這篇的做法~ 說明 再幫各位複習 一下，Image 其實是有很多層 Layer 的，而透過 docker run 建立了 container 後，會多一層可讀寫的 layer。 這個時候如果你針對那個可讀寫的 layer 增加了或減少了內容，都會被記錄在 metadata 中 而如果你想把這些異動的結果再變成 image 交給別人的話，這時候可以透過一個叫作 docker commit 的指令將異動的內容變成一個新的 Docker 實作 假設今天我們透過 ubuntu 的 image 建立了一個 container，指令如下: 1docker run -it --name ubuntu ubuntu /bin/bash 接著我們在 home 底下建立一個目錄與文字檔 1234cd homemkdir testecho \"Hello World\" &gt;&gt; hello.txtls -al 此時如果直接把 container 移除，再透過 ubuntu 的 image 重新建立 container，剛剛新建的目錄與文字檔都不會存在，而這是因為: ubuntu 官方的 image 自然不會有你建立的資訊 可讀寫的那一個 layer 尚未被保存 透過 docker commit 解決的方式如下: 1234567891011121314151617# 先跳出 container 的 bashexit# docker commitdocker commit ubuntu foobar/ubuntu# 檢查本機是否有 image 存在docker images | grep foobar/ubuntu# 移除原本的 containerdocker rm -f ubuntu# 透過新的 image 建立 containerdocker run -it --name ubuntu foobar/ubuntu /bin/bash# 看一下先前建立的資料是否還在ls -al home 此時的 container 概念上可以分成三塊 原本官方 ubuntu 的 image layer(s) 剛透過 docker commit 建立的 layer 啟動 container 時新加上的可讀寫 layer 結論: 針對 container 的一次性異動可以透過這種方式處理 重覆性的操作則建議用 Dockerfile，下篇會詳述","link":"/2022/02/10/%E3%80%90%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BA%20Docker(4)%E3%80%91%20-%20docker%20commit/"},{"title":"【深入淺出 Spring Security(1)】- Spring Security 是什麼？","text":"如果有這機會建立一個新的 Spring Project，一定會要花時間處理 Security 的部份。這段說難…真的很難！而且只設定一次，之後也許就再也沒機會碰到了 …筆者最初碰到的時候真的是暈頭轉向，碰一次忘一次，因此決定重新鑽研這一塊並留下筆記與重點，供後人參考之 什麼是 Spring Security？ 它是一個 Spring Project，可參考官方文件 它負責處理 Authentication、Authorization 它支援所有風險相關的防護(e.g. OWASP Top Ten Vulnerabilities) 它在網頁是一個 “Servlet Filter”","link":"/2022/11/07/%E3%80%90%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BA-Spring-Security-1-%E3%80%91-Spring-Security-%E6%98%AF%E4%BB%80%E9%BA%BC%EF%BC%9F/"},{"title":"【深入淺出 Docker(3)】 - image 是什麼","text":"什麼是 Docker Image？這東西可是 Docker 裡面相當重要的一個要素，沒有它就無法建立 Container，至於為什麼呢？ 組成 正確來說 Image 是 Layers of Image，如果以盤子比喻的話，大概就是一疊盤子 就是你會在資料結構的書上看到的堆疊結構那個樣子，我個人稱之為 Layers of Image 每一一個 Image layer，其內容物為一個含有多個 File 的 Filesystem，透過一個叫作 Union File System 的技術 將每一個層結合再一起，讓你「看起來」是只有一個 Filesystem。 建立 這每一層的 Layer 又是怎麼形成的呢？ 必須要透過一個叫 Dockerfile 的指令腳本來指示建立 Dockerfile 的每一條指令，從 FROM, RUN, COPY, … ENTRYPOINT 等等，都會先建立一個暫時的 container，執行完指令之後，把結果記錄成一個 image layer，而最後最後的結果，其實就是最後一個指令執行完的 image layer 的 ID 以下是一個 Dockerfile 的範例: 123456789101112# nginx state for serving contentFROM --platform=linux/amd64 nginx:alpine# Set working directory to nginx asset directoryWORKDIR /usr/share/nginx/html# Remove default nginx static assetsRUN rm -rf ./*# COPY the result of ng build --prod to WORKDIRCOPY dist/avc-frontend .COPY default.conf /etc/nginx/conf.d/default.conf# Containers run nginx with global directives and daemon offENTRYPOINT [\"nginx\", \"-g\", \"daemon off;\"] 如果想看完整的一個 image 總共有多少 layers，可以透過 docker history，如下: 使用 在我們執行 docker run 的時候，就會在這一個 Layers of image 的頂端建立一個可讀寫的 layer 這意味著了「那一層」之外，所有以下的 Image layer 都是唯讀的，因此這些唯讀的 Image Layer 在不同的 container 間是可以共用的 共用意味著相同內容的 Image layer，就只需要下載一份即可 這也是為什麼有時候在 docker pull 或是 docker build 的時候可以看到 use cache，因為已經有相同內容物的 Image layer 存在了，直接拿來使用就好了。 結論: container 是一個 linux process container 本身所能讀或寫的 filesystem 就是所有唯讀的 image layer 組合起來，再加上它自己可讀寫的那一層 image 是透過 Dockerfile 所寫的腳本透過 docker engine 產出來的","link":"/2022/01/30/%E3%80%90%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BA%20Docker(3)%E3%80%91%20-%20image%20%E6%98%AF%E4%BB%80%E9%BA%BC/"},{"title":"【深入淺出 Docker(2)】- Docker 是什麼","text":"如果有天長官問說「Docker 是什麼？」不知道在座的您會如何回答呢？ What is it？ Docker 是基於 LXC(Linux Container) 的「其中一種」容器建立技術。 建立容器只是其中一種技術，並不代表 Docker 就是容器， 容器還有其他公司有做(舉例: rkt, mesos, rancher… 等等) 特性 它與 Host OS 共享資源 12Host OS 指的是 Docker 被安裝的作業系統有可能是實體機器本身的作業系統，也可能是 VM 上的作業系統 它相對具可攜性，只要機器有裝 Docker Engine，不管在哪運行原則上不會有差異 它相對輕量，一個指令就可以建立，不用像 VM 還要安裝整套的作業系統 它相對容易建立，不用再安裝這個 Framework 那個 掛那個 dll，設定環境變數… 組成 Docker Engine =&gt; 又分作實際做事的 Docker Deamon 與跟 Daemon 互動的 Docker Client Docker hub =&gt; 負責存放 Docker Image 的一個 Registry Linux vs. Others 一般在 Linux 的任何一個 Distribution 上安裝的都是原生的 Docker Mac / Windows (Pro)/ Win 10 + WSL2 上安裝的，中間其實都偷偷墊了一層 VM，也因為如此，測試機才會是直接裝 Docker，而本機開發也可以用安裝包處理 不論在哪種 OS 下，面對 Docker Engine 的操作模式都會是一樣的！ 總結 容器就是應用程式與其所有相依套件於一體的 Linux Process 前面提到的 Image 是什麼？ 詳細的以後再寫一篇來談","link":"/2022/01/30/%E3%80%90%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BA%20Docker(2)%E3%80%91-%20Docker%20%E6%98%AF%E4%BB%80%E9%BA%BC/"}],"tags":[{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"Spring Security","slug":"Spring-Security","link":"/tags/Spring-Security/"}],"categories":[]}