{"pages":[{"title":"GC's Garbage Collector","text":"Hi, my name is George I´m striving to become a System Architect Loves everything related to Java My Skills JavaScript VanillaJS ES6 TypeScript Angular Tests Jasmine Selenium JUnit Mockito Tooling Webpack Maven Java OO Servlet/JSP Spring Boot CI/CD Jenkins Gitlab Github Actions Docker Kubernetes Main projects Schedule Manager A backend microservice used to manage schedules The objective is to manage all kinds of scheduled tasks","link":"/index.html"},{"title":"關於我","text":"學經歷 大學主修外文，英文為主，日文為輔 碩士主修經濟，擅長個體經濟、計量經濟 半路出家的 Java Programmer 目前為 Full Stack Engineer(自稱) 技術專長Dev(後端) Java SE 的基本 API(OCPJP 7) Spring Framework(Core/Boot/…etc.) MySQL、MSSQL、postgreSQL REDIS MongoDB RabbitMQ、Apache Kafka Dev(前端) Vanilla JS Angular Kendo UI Ops Jenkins 建立完整的 CI/CD 流程 從 commit 到 deploy 均不需額外的功 Docker 將舊系統容器化，建立一致的 Tomcat/Spring boot 用 Dockerfile 建立一致的 docker-compose.yml Kubernetes 建立從 ingress 到 deployment 的 YAML 檔 善用 fast storage/configmap/secret 搭配 Spring Cloud Configuration 中央管理設定檔 透過 Fluentd + Elasticsearch 中央管理日誌","link":"/about/index.html"}],"posts":[{"title":"【深入淺出 Docker(1)】 - Docker 命名由來","text":"平常大家都聽到或稱呼 Docker 習慣了，但您是否知道它的命名由來呢？我相信每一個產品的命名都有它一定的淵源，無論其命名是市場導向，或別有用途，了解它的命名，或許對整體概念能有多一些認識。 歷史 在古早時代，每一種貨物都有其不同的打包方式。亦或是針對它內容物的性質不同，需要特別的環境安置之… 然而在碼頭不可能針對每一項貨物都出專用的工具，或是配置特別的環境處理某些類型的貨物，於是…有人就想出了貨櫃這個打包方式！ 只要你的貨進了貨櫃，那在碼頭的工作人員就不必擔心如何將貨物放置至船上，只要考慮每一個貨櫃的配重即可。 即使是那些需要特殊環境的貨物，只要放進特殊環境的貨櫃即可，再也不用在船上特別提供環境~ 比擬 Docker 與 Container 這個命名的由來，是根據「貨物」透過「貨櫃」的統一置放方式而來 Container 本身除了在 Linux OS 是一個 Process 之外，也暗喻我們所開發的 Application 是以一個「打包好的形式」被部署在各個環境中。 也正因如此， Docker 的 Logo 是隻鯨魚上面載著許多貨櫃，就好比是應用程式被以統一包裝方式(container) 被部署。 小結 不知看了這篇，是否對 docker 本身又更興趣多了點？ 其實容器不只 docker 一種，詳細的以後再寫一篇來談","link":"/2022/01/30/%E3%80%90%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BA%20Docker(1)%E3%80%91%20-%20Docker%20%E5%91%BD%E5%90%8D%E7%94%B1%E4%BE%86/"},{"title":"【深入淺出 Docker(4)】 - docker commit","text":"除了前篇稍微提到的 Dockerfile，還有一種方式可以建立 image如果只是想快速建立一個 snapshot 性質的 image，又不想撰寫完整的 Dockerfile，可以參考這篇的做法~ 說明 再幫各位複習 一下，Image 其實是有很多層 Layer 的，而透過 docker run 建立了 container 後，會多一層可讀寫的 layer。 這個時候如果你針對那個可讀寫的 layer 增加了或減少了內容，都會被記錄在 metadata 中 而如果你想把這些異動的結果再變成 image 交給別人的話，這時候可以透過一個叫作 docker commit 的指令將異動的內容變成一個新的 Docker 實作 假設今天我們透過 ubuntu 的 image 建立了一個 container，指令如下: 1docker run -it --name ubuntu ubuntu /bin/bash 接著我們在 home 底下建立一個目錄與文字檔 1234cd homemkdir testecho \"Hello World\" &gt;&gt; hello.txtls -al 此時如果直接把 container 移除，再透過 ubuntu 的 image 重新建立 container，剛剛新建的目錄與文字檔都不會存在，而這是因為: ubuntu 官方的 image 自然不會有你建立的資訊 可讀寫的那一個 layer 尚未被保存 透過 docker commit 解決的方式如下: 1234567891011121314151617# 先跳出 container 的 bashexit# docker commitdocker commit ubuntu foobar/ubuntu# 檢查本機是否有 image 存在docker images | grep foobar/ubuntu# 移除原本的 containerdocker rm -f ubuntu# 透過新的 image 建立 containerdocker run -it --name ubuntu foobar/ubuntu /bin/bash# 看一下先前建立的資料是否還在ls -al home 此時的 container 概念上可以分成三塊 原本官方 ubuntu 的 image layer(s) 剛透過 docker commit 建立的 layer 啟動 container 時新加上的可讀寫 layer 結論: 針對 container 的一次性異動可以透過這種方式處理 重覆性的操作則建議用 Dockerfile，下篇會詳述","link":"/2022/02/10/%E3%80%90%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BA%20Docker(4)%E3%80%91%20-%20docker%20commit/"},{"title":"【深入淺出 Spring Security(1)】- Spring Security 是什麼？","text":"資安是個 non-functional requirement如果沒人特別要求，或許也不會有人在乎但試想如果銀行的系統出問題了…你的錢就變成別人的錢了呢，是否開始有點同理心了呢？ 什麼是 Spring Security？ 它是一個 Spring Project，詳細內容可參考官方文件 只要掛上 dependency 就可以使用 可透過 XML 或 JavaConfig 設定要防護什麼，怎麼防護 它是 “Application” 層級的防護 它負責處理或支援 Authentication、Authorization 它支援不少風險相關的防護(e.g. OWASP Top Ten Vulnerabilities) 它在 Java Web App 是一個 “Servlet Filter” 它協助處理密碼的管理與加密 Authentication Authentication 指的是確認目前的使用者是誰 在驗證身份的時候可能需要帳密，也可能是透過外部系統(e.g. AD, LDAP, Google/FB/Twitter..) 在驗證前，不能對系統作任何的操作 Authorization Authorization 指的是在確定使用者身份後，區分出這個使用者可存取的權限 比方說可以簡單分 read, write，或是更嚴謹的角色、範疇 OWASP 是 Open Web Application Security Project 的縮寫 上面列出了每一個年度最常被攻擊的風險 很多開源或付費的解決方案 常見的風險如 XSS、SQL Injection、CSRF …等 詳細資訊可參考官方網站 Servlet Filter 只要是寫 Java 後端就必備的知識，會在 Request 進來的時，真正進到 Filter 之前處理 是一種 Chain Of Responsibility Pattern 的變型 Spring Security 正是掛了一整串的 Filter，處理各式各樣的需求如 Authentication、Authorization、Token 解析…等 PasswordEncoder 任何有機密性質的資料都不該被明文儲存(e.g. 使用者密碼) Spring Security 可以透過設定不同的 encoder，用以比對或運算出一組被編碼過的值 為什麼要防護？ 大家都防了你沒防，就好比整條街只有你家大門是開著的 被攻擊的成本遠大於花時間防護 Spring Security 的設定相對輕鬆容易，不會有一堆干涉商業邏輯的程式存在 小結 Spring Security 是用來加在程式上的一道防護 Spring Security 可透過不同段的流程驗證使用者的身份與權限 Spring Security 可幫助防護 OWASP 中提列出的風險","link":"/2022/11/07/%E3%80%90%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BA-Spring-Security-1-%E3%80%91-Spring-Security-%E6%98%AF%E4%BB%80%E9%BA%BC%EF%BC%9F/"},{"title":"【深入淺出 Docker(3)】 - image 是什麼","text":"什麼是 Docker Image？這東西可是 Docker 裡面相當重要的一個要素，沒有它就無法建立 Container，至於為什麼呢？ 組成 正確來說 Image 是 Layers of Image，如果以盤子比喻的話，大概就是一疊盤子 就是你會在資料結構的書上看到的堆疊結構那個樣子，我個人稱之為 Layers of Image 每一一個 Image layer，其內容物為一個含有多個 File 的 Filesystem，透過一個叫作 Union File System 的技術 將每一個層結合再一起，讓你「看起來」是只有一個 Filesystem。 建立 這每一層的 Layer 又是怎麼形成的呢？ 必須要透過一個叫 Dockerfile 的指令腳本來指示建立 Dockerfile 的每一條指令，從 FROM, RUN, COPY, … ENTRYPOINT 等等，都會先建立一個暫時的 container，執行完指令之後，把結果記錄成一個 image layer，而最後最後的結果，其實就是最後一個指令執行完的 image layer 的 ID 以下是一個 Dockerfile 的範例: 123456789101112# nginx state for serving contentFROM --platform=linux/amd64 nginx:alpine# Set working directory to nginx asset directoryWORKDIR /usr/share/nginx/html# Remove default nginx static assetsRUN rm -rf ./*# COPY the result of ng build --prod to WORKDIRCOPY dist/avc-frontend .COPY default.conf /etc/nginx/conf.d/default.conf# Containers run nginx with global directives and daemon offENTRYPOINT [\"nginx\", \"-g\", \"daemon off;\"] 如果想看完整的一個 image 總共有多少 layers，可以透過 docker history，如下: 使用 在我們執行 docker run 的時候，就會在這一個 Layers of image 的頂端建立一個可讀寫的 layer 這意味著了「那一層」之外，所有以下的 Image layer 都是唯讀的，因此這些唯讀的 Image Layer 在不同的 container 間是可以共用的 共用意味著相同內容的 Image layer，就只需要下載一份即可 這也是為什麼有時候在 docker pull 或是 docker build 的時候可以看到 use cache，因為已經有相同內容物的 Image layer 存在了，直接拿來使用就好了。 結論: container 是一個 linux process container 本身所能讀或寫的 filesystem 就是所有唯讀的 image layer 組合起來，再加上它自己可讀寫的那一層 image 是透過 Dockerfile 所寫的腳本透過 docker engine 產出來的","link":"/2022/01/30/%E3%80%90%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BA%20Docker(3)%E3%80%91%20-%20image%20%E6%98%AF%E4%BB%80%E9%BA%BC/"},{"title":"【深入淺出 Docker(2)】- Docker 是什麼","text":"如果有天長官問說「Docker 是什麼？」不知道在座的您會如何回答呢？ What is it？ Docker 是基於 LXC(Linux Container) 的「其中一種」容器建立技術。 建立容器只是其中一種技術，並不代表 Docker 就是容器， 容器還有其他公司有做(舉例: rkt, mesos, rancher… 等等) 特性 它與 Host OS 共享資源 12Host OS 指的是 Docker 被安裝的作業系統有可能是實體機器本身的作業系統，也可能是 VM 上的作業系統 它相對具可攜性，只要機器有裝 Docker Engine，不管在哪運行原則上不會有差異 它相對輕量，一個指令就可以建立，不用像 VM 還要安裝整套的作業系統 它相對容易建立，不用再安裝這個 Framework 那個 掛那個 dll，設定環境變數… 組成 Docker Engine =&gt; 又分作實際做事的 Docker Deamon 與跟 Daemon 互動的 Docker Client Docker hub =&gt; 負責存放 Docker Image 的一個 Registry Linux vs. Others 一般在 Linux 的任何一個 Distribution 上安裝的都是原生的 Docker Mac / Windows (Pro)/ Win 10 + WSL2 上安裝的，中間其實都偷偷墊了一層 VM，也因為如此，測試機才會是直接裝 Docker，而本機開發也可以用安裝包處理 不論在哪種 OS 下，面對 Docker Engine 的操作模式都會是一樣的！ 總結 容器就是應用程式與其所有相依套件於一體的 Linux Process 前面提到的 Image 是什麼？ 詳細的以後再寫一篇來談","link":"/2022/01/30/%E3%80%90%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BA%20Docker(2)%E3%80%91-%20Docker%20%E6%98%AF%E4%BB%80%E9%BA%BC/"},{"title":"【深入淺出 Spring Security(2)】- Hello World(Part I)","text":"如同平時學程式語言一般，我們也從 Hello World 開始吧！這篇我們會從無到有，建立一個簡單的 endpoint，接著再加入 Security 的元素，並簡單說明框架幫忙做了什麼！ 「無」 Spring Security 版本首先就來一個不包含 Spring Security 的 project 建立一個 Project 建立的方式就參照各大網站的教學建立一個 Maven Project 建立的是 Spring Boot Application，其中 starter 的部份請選擇 Spring-Web，才能處理基本的請求／回應 此時的 pom.xml 中的 dependency 大致上長這樣 123456789101112 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 建立一個 Endpoint 首先在 base package 建立一個 HelloController 接著開出一個方法，回傳的型態是 String 最後在實作的部份回傳 “Hello World” 程式碼大致上會如下: 12345678910111213package org.dream.helloworld;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloWorldController { @GetMapping(value = \"hello\") public String hello() { return \"Hello World\"; }} @RestController 隱含著 @ResponseBody，代表回傳的結果會是透過預設的 HttpMessageConverter(Jackson) 處理 @GetMapping 代表這個方法接受 HTTP GET 驗證功能 首先啟動你的 Spring Boot Application 接著打開瀏覽器，並在網址列輸入 localhost:8080/hello，最後按下 enter 就會在瀏覽器看到如下的畫面囉 「有」Spring Security 版本接著就替我們的程式加上防護吧！ 補上 dependency 先把先前啟動的服務停掉(除非有掛上 dev-tools) 在 pom.xml 的 dependencies 中間加上以下 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 這個是 spring boot 針對 security 提供的 starter 有興趣可以展開它的內容看看大致上包含了什麼東西 接著再啟動一次服務，就會在 console 看到如下的畫面 紅框框起來的部份，是框架產出的密碼，可以先複製到剪貼簿上 紅框下方可以看到服務自動被掛上了 DefaultSecurityFilterChain 最後再重試造訪一次 localhost:8080/hello 咦？需要登入了！ 此時輸入帳號 user，密碼為前面複製起來的值，就可以看到如同先前尚未掛上 Spring Security 時的結果 註1: 如果輸錯帳密就會看到以下畫面 註2: 可以嘗試一下以如用 curl 會是什麼結果 Spring Security 簡述Spring Security 的流程 首先請求進到服務，被 AuthenticationFilter 攔截 這個 Filter 跟 Java EE 中的 ServletFilter 是近乎相同的概念 這個 Filter 預設會解析請求的 Header 中所包含的使用者與密碼當作 Token，這也是為什麼用帳號密碼可以登入 接著「驗證」被交給 AuthenticationManager 處理 AuthenticationManager 把驗證委派給一至多個 AuthenticationProvider 處理 常見的實作有 Ldap、Dao、OAuth2 …等 也可以自定義！ AuthenticationProvider 把找人的部份交給了 UserDetailsService，並把密碼屏蔽的部份交給了 PasswordEncoder UserDetailsService 可以自行實作，或用 Spring Security 內建提供的，如同範例用到的就叫 InMemoryUserDetailsService(後續會再提) PasswordEncoder 常見的有 BCrypt、SCrypt、NoOp …等內建的 以上的結果會存放到 SecurityContext 可以把它當作一個存放登入後的資訊的點 這是一個 In-Memory 且 ThreadLocal 的值 流程圖大略如下: 從系統角度看它做了什麼？ 實作 UserDetailsService 並建立一個 user，且設定帳密 設定 HTTP Basic Authentication 防護「所有的」 endpoint，需 Authenticate 過才能存取 很多其它的元件被設定了預設值(目前還沒看到) 這樣就好了？ 當時不是，雖然目前系統已加上了防護，但仍有幾個問題 帳密只有一組(如果別人也要使用服務？) 密碼印在 console(這風險還不夠大嗎？) 所有的 endpoint 都被防護 驗證的方式並非自行設定的 .. …(略) 除了以上提到的部份之外，請留意這就是 Convention over Configuration 什麼都不用做，或是照一些慣例設定就可以達到很複雜的功能的基本設定 但這不代表真的所有系統都完全不用再設定了 小結 從此篇可以了解到，掛上 dependency，spring security 做了什麼預設的處理 下一篇開始將依 Spring Security 各個環節提供自訂的實作 備註 原始碼請參考連結","link":"/2022/11/09/%E3%80%90%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BA-Spring-Security-2-%E3%80%91-Hello-World/"},{"title":"【深入淺出 Spring Security(3)】- Hello World(Part II)","text":"前一篇我們套用了預設的組態但很顯然這是不夠的 …要如何才能自定義那些預設的行為呢？ 覆寫預設的組態InMemoryUserDetailsManager 在預設的組態中，使用者永遠是 user，而密碼是啟動系統時隨機產出的一組像是 UUID 的值 此時可以使用 Spring Security 預設的類別，叫 InMemoryUserDetailsManager 首先先定義一個類別叫 SecurityConfiguration，其內容如下: 123456789101112131415161718import java.util.Arrays;import java.util.List;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.core.userdetails.User;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.provisioning.InMemoryUserDetailsManager;@Configurationpublic class SecurityConfiguration { @Bean public InMemoryUserDetailsManager inMemoryUserDetails() { return new InMemoryUserDetailsManager(); }} 尚未設定任何使用者 InMemoryUserDetailsManager 被設成 Bean，啟動系統時會被注入 啟動系統後請留意兩件事 系統不再自動產生一組隨機密碼 此時如用 curl 去打先前定義的 hello endpoint，會回傳 401，如下所示: 可如果就停在這，也無法登入，因此還要接著設定使用者如下: 123456789List&lt;UserDetails&gt; userDetails = Arrays.asList( User.builder() .username(\"test\") .password(\"12345\") .authorities(\"ROLE_ADMIN\") .build() ); return new InMemoryUserDetailsManager(userDetails); 這邊多定義了個 UserDetails 的 List UserDetails 可透過 User.builder 建立 建立時基本上必須提供 username, password, authorities(詳見下方) PasswordEncoder 這個時候如果再試一次 curl，仍然會是 401，而 console 會出現以下的錯誤訊息 主要是在描述在比對密碼時，找不到一個對應的 PasswordEncoder 可使用 這個訊息可以從 DelegatingPasswordEncoder 中看到(後續會再詳談) 既然缺 PasswordEncoder 我們就補一個給它！ 1234@Beanpublic PasswordEncoder passwordEncoder() { return NoOpPasswordEncoder.getInstance();} NoOpPasswordEncoder 顧名思義就是只比對純文字 從 IDE 看的話它會提示你這是 @Deprecated 的類別，但沒關係，這只是開發時期用的(應該吧) 此時，curl 應該就會正常顯示 Hello World Authorization 還記得前面提到預設是阻擋所有的 endpoint 嗎？ 這個部份主要是覆透過 Authorization 的設定可異動的 首先在 SecurityConfiguration 中再定義一個 Bean 如下: 12345678910@Beanpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .authorizeRequests() .anyRequest().authenticated() .and() .httpBasic(); return http.build();} 從 Spring Security 5.7 開始，都會定義在 SecurityFilterChain，舊時代的 WebSecurityConfigurerAdapter 在不久的未來會被移除 anyRequest 就是任何 URL 都要授權 authenticated 代表要驗證過身份 綜上所述，以白話來說就是任何請求都要登入，跟預設的行為是一致的，所以即使加上這一設定，curl 還是可以動(因為有在 header 附上帳密) Q&amp;A 我要開放！ Q: 如果我想要不登入也能打 hello 這個 endpoint 呢？ A: 此時把 authenticated 改成 permitAll 即可 不加密不會出事嗎？ Q: 難道只有 NoOpPasswordEncoder 可以用？ A: 當然不，後續會再提到別種 Encoder Basic Authorization Q: 我看那個 header 有個 **Basic dGVzdDoxMjM0NQ==**，什麼鬼？ A: 其實這是 username/password 的 透過 Base64 encode 之後的結果 有興趣可以在瀏覽器透過 btoa/atob 對字串處理 它不具安全性，有心的人如果攔截到還是可以看到明文喔！ 全擋？ Q: 不能針對特定 URL 開放某種權限嗎？ A: 可，後續會再深談 小結 定義了 InMemoryUserDetailsManager 覆寫了 Authentication 時用到的帳密設定 定義了 NoOpPasswordEncoder，以純文字比對密碼 定義了 SecurityFilterChain 處理 Authorization 下一篇會再透過另一種方式覆寫預設的行為 備註 原始碼請參考連結","link":"/2022/11/18/%E3%80%90%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BA-Spring-Security-3-%E3%80%91-Hello-World-Part-II/"},{"title":"【深入淺出 RabbitMQ(1)】- RabbitMQ 是什麼？","text":"軟體開發的世界中，溝通的方式有很多種。從單一程式內部的方法呼叫(Procedure call)到單一OS內的跨行程呼叫(Inter Process call)到不同機器間遠端的呼叫的 RPC(e.g. RMI, CORBA)而 RabbitMQ 可以支援上面所有的溝通方式 什麼是 RabbitMQ？MQ 是 Message Queue 的縮寫 Queue 是一種資料結構，有著 FIFO 的特性 在 Java 中預設可以在 java.util.Queue 看到介面的定義，常見的實作有: ArrayDeque，底層是陣列的實作 BlockingQueue，主要用在處理多執行緒的情境 …(略) 它是一種 Message Broker Broker 的中文翻譯就是經紀人、中間人、調停人…等 Stock Broker 就是股票經紀人 Real-estate Broker 就是房地産經紀人 以此類推，RabbitMQ 就是訊息的經紀人，也就是說訊息本身會透過它來傳遞，而且是以 Queue 的資料結構在處理訊息 它主要支援的協定是 AMQP AMQP 是 Advanced Message Queue Protocol 的縮寫 目前 RabbitMQ 支援的版本是 AMQP 0-9-1 其它還有 AMQP 0-10、AMQP 1.0 …等就不在此多談 此外 RabbitMQ 還支援 STOMP、MQTT、RabbitMQ Streams…等協定 主要有三個角色 Broker 就是 RabbitMQ 本身 負責接收訊息，存放訊息，分派訊息 Producer 就是一般說的生產者 負責產出訊息 Consumer 就是一般說的消費者 負責接收訊息 什麼時候會用到？反向思考，RabbitMQ 支援的是: 非同步的訊息溝通 訊息會先從生產者發到 RabbitMQ，再由消費者從 RabbitMQ 取得 從這個點來看，很適合排程類的任務，或是不需要馬上通知系統使用者結果的(e.g. 信用卡送件審核) 此外，因為生產者、消費者雙方解耦，因此也不用特別綁定某一組 HOST + PORT，或是透過 service discovery 的機制處理溝通 可靠的重試機制 在 AMQP 協定中，消費者可透過 ACK (Acknowledgement) 的機制通知 RabbitMQ 訊息已確定收到 承上，生產者也可以透過 Transaction 或是 publisher confirm 確定訊息有被正確送到 RabbitMQ 以上所提的機制，可以很單純地達到 Retry 的機制，而不用一堆複雜的 Error Handling 或是 Circuit Breaker 設計模式處理訊息發送或接受失敗的狀況 幾個可以判斷的基準 與同步溝通(e.g. REST API) 之間的差異 是否有需要完全解耦 是否有需要可靠的重試機制 小結 RabbitMQ 是一種 Message Broker RabbitMQ 可簡單處理非同步的溝通 RabbitMQ 讓重試機制變得單純","link":"/2023/02/01/%E3%80%90%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BA-RabbitMQ-1-%E3%80%91-RabbitMQ-%E6%98%AF%E4%BB%80%E9%BA%BC%EF%BC%9F/"},{"title":"【深入淺出 RabbitMQ(2)】- Hello World","text":"每當學一項技術或語言，不免俗就是要來一下初步能動的程式本篇將講解如何啟動 RabbitMQ，並簡單處理訊息收發 安裝 RabbitMQ首先自然是要安裝 RabbitMQ 啦！為了省功夫，就用 Docker 建 container 就好之後如果有時間再補上 Windows/Mac/Linux 個別的安裝方式 Docker透過 docker 安裝會相對單純許多，主要分為以下幾個步驟: 設定 docker-compose.yml 建立 docker network 建立並啟動 RabbitMQ container 設定 docker-compose.yml 首先建立 docker-compose.yml 如下: 123456789101112131415161718192021222324version: '3.7'services: rabbit: image: rabbitmq:3.11.8-management container_name: rabbit expose: - \"5672\" - \"15672\" ports: - \"5672:5672\" - \"15672:15672\" networks: - dreamer volumes: - rabbitmq-data:/var/lib/rabbitmq environment: TZ: Asia/Taipeivolumes: rabbitmq-data:networks: dreamer: external: true name 設定容器的名稱為 rabbit 下指令的時候比起 ID 好記許多 image 抓的是 management 版本，版號目前最新就是 3.11.8 可透過 UI 管理介面設定或監控一些數據 ports 5672 為預設的 TCP port，用以建立連線 15672 為管理介面的 UI 使用 volume 主要是為了讓之後異動的設定能保留 接著建立 docker network 1sudo docker network create dreamer 這段是設定一個自定義的 bridge 之後如果有直接跟其它的 container 透過 name 當作 domain name 溝通的話挺方便的 最後建立並啟動容器 1sudo docker-compose up -d 如果有正常啟動的話，畫面會如下 日誌 1sudo docker logs rabbit 有看到 5672 開始被監聽應該就正常了 設定使用者帳密在使用之前一定要先設定帳密，雖然預設會給一組 guest/guest，但會有以下問題: 資安問題: 因為大家都會知道這組 連線問題: 預設 guest 使用者是不開放 localhost 以外的連線的，所以如果你的 RabbitMQ instance 不是在本機的就會出現以下的訊息: 登入 首先先連到 RabbitMQ 的管理畫面，預設是 host:15672 建立帳密 在以 guest/guest 登入後，切到 Admin 的頁籤 先展開 Add a user 的小三角形 接著輸入新的帳號密碼(我用的是 rmqdemo/rmqdemo) 再來點選 Admin，讓 rmqdemo 這個使用者有 admin 的權限(正式環境請切分清楚權限) 最後再按 Add user 新增後會看到的畫面如下: 可以看到一個黃黃的 No Access 這是因為還沒指定任何 Virtual host 給使用者 設定 Virtual Host 此時對著 rmqdemo 點下去會進到如下頁面 再來直接按下 Set permission 就可以了 Virtual Host 就是在 RabbitMQ 底下切出幾個虛擬的主機，用來切分不同 domain 的 Queue 用 比方說我有很多個系統(e.g. 會計系統、人事系統)，它們都同時使用 RabbitMQ 假設這兩個系統有某些部份完全不互相往來，為了不讓兩個系統間誤觸或讀寫對方使用到的訊息，可以這樣劃分 設定 / 代表的是所有的 Virtual Host 都有存取的權限 建立生產者與消費者 使用的語言為 Java(17) 專案的套件管理為 Maven 用到的 library 為 amqp-client 不論是生產者或消費者，在溝通前一律需要: 建立 ConnectionFactory 從 Factory 取得連線(com.rabbitmq.client.Connection) 利用 Connection 建立 Channel 生產者 目的: 要送出一個訊息，內容為 Hello World 流程: 先建立 Queue，名稱為 DEMO_QUEUE 送出一個訊息內容 Hello World 到剛建立的 Queue 程式如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.io.IOException;import java.util.Objects;import java.util.concurrent.TimeoutException;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;import lombok.extern.slf4j.Slf4j;@Slf4j@SpringBootApplicationpublic class DemoApplication implements CommandLineRunner { private static final String RMQ_HOST = \"192.168.64.3\"; private static final int RMQ_PORT = 5672; private static final String RMQ_USER = \"rmqdemo\"; private static final String RMQ_PASS = \"rmqdemo\"; public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } @Override public void run(String... args) throws Exception { ConnectionFactory factory = new ConnectionFactory(); factory.setHost(RMQ_HOST); factory.setPort(RMQ_PORT); factory.setPassword(RMQ_PASS); factory.setUsername(RMQ_USER); Connection connection = null; Channel channel = null; try { connection = factory.newConnection(); channel = connection.createChannel(); String message = \"Hello World\"; channel.queueDeclare(\"DEMO_QUEUE\", false, false, false, null); channel.basicPublish(\"\", \"DEMO_QUEUE\", null, message.getBytes()); log.info(\"[Producer] - Message sent : {}\", message); } catch(IOException | TimeoutException ex) { log.error(\"Error during message publish\", ex); } finally { if(!Objects.isNull(connection)) { connection.close(); } } }} 43 的部份就是透過 channel.queueDeclare 建立一個 RabbitMQ 上的 Queue 44 的部份將訊息送出，只能傳送 byte[]，因此還呼叫了 String 的 getBytes 方法轉換 這邊不論建立或呼叫時，其它的參數暫時還不重要，記得第一個是 Queue 的名稱即可，剩餘的後面會再詳談 消費者 目的: 要接收一個訊息，並輸出其內容 流程: 先建立 Queue，名稱為 DEMO_QUEUE 建立一個 DeliverCallback，定義收到訊息時的處理 開始從剛建立的 Queue 接收訊息 程式如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.io.IOException;import java.nio.charset.StandardCharsets;import java.util.concurrent.TimeoutException;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;import com.rabbitmq.client.DeliverCallback;import lombok.extern.slf4j.Slf4j;@Slf4j@SpringBootApplicationpublic class DemoApplication implements CommandLineRunner { private static final String RMQ_HOST = \"192.168.64.3\"; private static final int RMQ_PORT = 5672; private static final String RMQ_USER = \"rmqdemo\"; private static final String RMQ_PASS = \"rmqdemo\"; public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } @Override public void run(String... args) throws Exception { ConnectionFactory factory = new ConnectionFactory(); factory.setHost(RMQ_HOST); factory.setPort(RMQ_PORT); factory.setPassword(RMQ_PASS); factory.setUsername(RMQ_USER); try { Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; { String message = new String(delivery.getBody(), StandardCharsets.UTF_8); log.info(\"[Consumer] - Received '\" + message + \"'\"); connection.close(); }; log.info(\"[Consumer] - Started consuming ...\"); channel.queueDeclare(\"DEMO_QUEUE\", false, false, false, null); channel.basicConsume(\"DEMO_QUEUE\", true, deliverCallback, consumerTag -&gt; {}); } catch(IOException | TimeoutException ex) { log.error(\"Error during message publish\", ex); } }} 42-46 定義了 DeliverCallback，這個方法在開始接收訊息的時候必須傳入，目前比較重要的參數就是 delivery，會透過其 getBody 方法取得訊息內容 49 宣告了 Queue 50 開始接收訊息 當真的有接收到訊息的時候，就會進到剛定義的 callback，也就是 43-45 的部份 先是把收到的訊息輸出到 log 接著就把連線中斷了 在這邊直接把連線中斷的原因是因為我很明確知道只有一條息，為了不 memory leak，而把 Connection 中斷，實際正式系統中的應用場景日後會再說明 送出與接收訊息生產者送出 執行生產者的 main 可以看到如下畫面 此時訊息已經透過生產者的程式送到 RabbitMQ 接著就沒生產者的事，可以直接結束整支程式也沒問題 消費者接收 執行消費者的 main 可以看到如下畫面 此時消費者也正確從 RabbitMQ 取得訊息 小結從此篇我們學到了: 如何透過 Docker 建立 RabbitMQ Instance 如何透過 RabbitMQ Management 建立一個有全權限的使用者 如何透過 Java 的 amqp library 建立生產者與消費者 備註 原始碼連結","link":"/2023/02/04/%E3%80%90%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BA-RabbitMQ-2-%E3%80%91-Hello-World/"},{"title":"【深入淺出 RabbitMQ(3)】- 訊息篇(Part I)","text":"Message Queue 傳遞的是訊息，但訊息在 RabbitMQ 的架構下是什麼？ 訊息是什麼？ 傳統定義上的訊息像是電子郵件、即時通訊等，可能是一般對訊息的認知，不過在 AMQP 的訊息有著一些特性 AMQP 像電子郵件 一樣可以設 tag AMQP 不像 電子郵件的部份是其 內容是可以是任何結構，甚至可以放 binary 型態的資料 生產者與消費者 如同此篇提到的，訊息有三個端點，生產者、消費者、Broker RabbitMQ 就如同是網路架構下的 router，而使用 RabbitMQ 的時候首先要決定的就是你是生產者或是消費者 在發送訊息的時候有幾個要素: payload 就是訊息的內容 不分格式，不過實際上可以看對應語言的 client library 而定 以 Java 的 amqp-client 來說，payload 是一個 byte[] label exchange，算是收發室的概念(後面會詳述) routing key，就是 tag 的概念，依 tag 來對訊息分類 fire-and-forget 生產者在送出訊息後，就不用管了，因為訊息已經到了 RabbitMQ 關於怎麼確認已經到 RabbitMQ 這件事後面會再提到，不過一般來說送出之後是不必同步等待的 這個特性對比於 REST API 在發訊息的候是必須等到對方回應，基於 HTTP request/response 的概念不一樣 one-directional 訊息發送是單向的，不會有對方發過來的 在接收訊息的時候有幾個要素: subscription 消費者會訂閱某個 Queue RabbitMQ 會收到訊息的時候發給所有的 subscriber payload 如同生產者送出的訊息一般，消費者最在乎的就是訊息本身 通常雙方會約定一個結果的長相再轉換(e.g. 從 byte[] 透過 ObjectMapper 轉換成物件) 雙方都不知道誰負責發或收，因此可以完全解耦收與發的雙方 Channel 訊息是透過 Channel 送出的，但 Channel 是什麼？ 考慮到如果每個訊息都要開關一個 TCP Connection TCP Socket 數量有限 頻繁開關很貴，效能問題 因此 RabbitMQ 是: 基於一個 TCP Connection 底下 建立多個 AMQP Channel 每一個 Channel 就是一個獨立的 Thread，多個 Thread 共享 TCP Connection 意境上可以想像成吸管裡插了很多牙籤，吸管就是 TCP Connection，Channel 就是牙籤 AMQP 三要素 如同此篇提到的，RabbitMQ 遵循的是 AMQP 這個通訊協定 AMQP 的三個要素有 Queue, Exchange, Binding 此篇會先以 Queue 為主 Queue建立 Queue Queue 需要先建立才能監聽，可透過 queue.declare 建立 Java 則是透過 Channel 的 queueDeclare 這個方法處理，其下有多種 overload 我自己最常用的有 5 個參數如下: queueName: 顧名思議就是 Queue 的名稱 durable: 也就是這個 Queue 是不是重開 RabbitMQ 就不見了(後續會再詳談) exclusive: 是不是限定某一個 consumer autoDelete: 在最後一個消費者取消註冊的時候自動移除 arguments: 其它的參數(種類太多有機會提到會說) 以前一筆 Hello World 的部份片段為例: 1channel.queueDeclare(\"DEMO_QUEUE\", false, false, false, null); queue 的名稱就是 DEMO_QUEUE durable 為 false，代表 RMQ 重開的這個 Queue 就消失了 exclusive 為 false，代表任何消費者都可以註冊 autoDelete 為 false，代表最後一個消費者取消註冊依然會保留 arguments 為 null 代表沒特別設定什麼其它的參數 建立 Queue 的時候也可以不指定名稱，會自動建立一組隨機的命名(e.g. amq.gen-kkcRbifmFzl4cVI6FLA4fQ==) 建立 Queue Q&amp;A 是否可以用同個名字 queue.declare？ 一般來說是沒問題的，因為如果同一個命名的 Queue 已經存在，就不會特別再建一次 此外，也可以透過 Channe.queueDeclarePassive 確認是否存在 如上圖，Queue 不存在就會拋出 Exception 此時 Channel 就會自動被關閉 誰應該負責建立 Queue，生產者或消費者？ 這取決於訊息本身是否可被遺漏 當生產者發送訊息，但沒有任何 Queue 負責接收的話，訊息就會直接像丟進黑洞一樣被吃掉 消費者則是一定要有 Queue 才能註冊 結論就是如果訊息不能丟失，雙方都要建立，否則就是消費者自己建立就好了 Queue 的運作 當同時有多個消費者註冊到同一個 Queue 時，訊息的發送是採 Round Robin(輪流) 的機制，讓大家都可以公平的被分到訊息，因此可以視為 Load balance 的一種 消費者如何註冊？ basic.consume 在 Java 就是 Channel.basicConsume 消費的時候可以選擇 autoAck 或是手動 ack，RabbitMQ 在收到 ack 的通知後就會將訊息從 Queue 上移除 發出 ack 之後，消費者會接著繼續處理下一訊息 p.s. ack 是 acknowledgement 的縮寫，表示「老子收到訊息了」 basic.get 如果不想一直處理訊息只要拿出單筆訊息，可以透過這個方法 每呼叫一次才會再取下一筆訊息 while(true) 搭配 basic.get，效能會比 basic.consume 差非常多 在 Queue 中沒有任何訊息的時候，消費者就是一直等待 如果消費者收到訊息後因為某種原因斷線了: 訊息會是處在 unacked 的狀態 此時 RabbitMQ 會將訊息再重新發回 Queue，交由其它的消費者處理，或是等斷線的消費者再上線 如果消費者收到訊息忘記 ack，那就會卡死，不會再收到新訊息 當收到的訊息有處理上有錯誤可以選擇: basic.reject，直接拒絕訊息 requeue 為 true，會再放回 queue requeue 為 false(RMQ &gt; 2.0.0)，可以透過 dead letter 的機制處理 不管，就是 ack，那訊息就會直接被丟掉 此時可以在 ack 前先想辦法再釋出一個訊息告知失敗 這個方法在很舊的 RabbitMQ 是適用的 小結 三個節點: 生產者、消費者、Broker 訊息三個要素: Queue, Exchange, Binding 消費前要先有 queue(basic.declare) 消費可以多筆或單筆(basic.consume vs. basic.get) 消費必須 ack 或是 reject 訊息","link":"/2023/02/07/%E3%80%90%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BA-RabbitMQ-3-%E3%80%91-%E8%A8%8A%E6%81%AF%E7%AF%87-1/"},{"title":"【深入淺出 RabbitMQ(4)】- 訊息篇(Part II)","text":"光有消費者？那可不夠，消費者是來消費的啊生產者又是如何將訊息推送至 RabbitMQ 的呢？ Exchange建立 Exchange 生產者發送的訊息其實是先直達 Exchange，因此要先建立之 Exchange 的建立是透過 exchange.declare 這個方法 在 Java client 則是透過 Channel.queueDeclare，常用的 5 參數 overload 如下: exchangeName: Exchange 的名稱 type: DIRECT/FANOUT/TOPIC(後續詳談) durable: 也就是這個 Exchange 是不是重開 RabbitMQ 就不見了(後續會再詳談) autoDelete: 沒被綁定的情況下就會自動刪除 arguments: 其它的參數(種類太多有機會提到會說) 不給名稱的 Exchange 可行？ 不行，跟 queue 不一樣，沒名字的 exchange 是有特殊意義的 RabbitMQ 預設就有建立一個沒名字的 Exchange 如果你嘗試建立名字為空字串的 exchange 就會發生以下的錯誤 為什麼不直接把訊息送到 Queue 就好？ 前面提過 RabbitMQ 的訊息有所謂的標籤的概念 Exchange 正是可以結合標籤的機制(後續詳談) 以電子郵件的角度類推，你可以收到某人透過信箱位址發給你的信件，你也可以收到被發給某個群組(e.g. 會計科) 的信件 這在某程度在生產者更不需要擔心訊息發給誰，甚至可以透過這個機制達一些複雜的轉介 Exchange 類型 Exchange 主要是搭配 Routing Key(標籤)，作為在發送訊息的時候需要一併提供的資訊 此外，Exchange 與 Queue 是需要 Binding(綁定) 來設定關係的，而這中間的識別值就是 Routing Key(後續詳談) Exchange 主要有分三種類型: DIRECT: 依 routing key 的值一對一對應到 Queue 當發送訊息不指定 exchange name，就會是用預設的 exchange，其類型為 DIRECT 如果預設的不夠，就自己建一個 exchange 綁定時需要 queueName, exchangeName, routing key FANOUT: 不用 routing key，綁定的 Queue 全會收到訊息 綁定時只要 queueName, exchangeName 就可以，routing key 空白 可以理解成廣播性質的息，而非特定單一 TOPIC: Routing key 在命名上會有萬用字元(wildcard) 假設有一個 queue(msg-inbox-logs)，且有一個 exchange(logs-exchange)，並在 binding 的時候設定 routing key 為(*.msg-inbox) 那麼發送訊息的時候，routing key 不論是 debug.msg-inbox、info.msg-inbox、error.msg-inbox，都會進到 msg-inbox-logs 這個 Queue 同樣的情境如果透過 DIRECT exchange，我就需要透過三組 Routing Key 來綁定 此外如果今天我不一定要送到 msg-inbox，那我可以再建立一個 binding，其規則為(info.*) 如此一來生產者在送出 info 等級的訊息時，routing key 也可以設定為 info.line、info.whatsapp、info.skype … 等，且以上都是對同一 個 exchange 發送訊息 重點整理 這裡來稍微作個重點整理: 單純從供需雙方的角度來看: 消費者會註冊到 Queue 生產者會對 Exchange 帶著 Routing Key 發送訊息 從 Broker 的角度來看: 必須有人建立 Queue、Exchange 必須有人建立上述兩者間的關係(Binding) 以 Java 的 amqp-client 來看: 建立 Queue 就是 Channel.queueDeclare 建立 Exchange 就是 Channel.exchangeDeclare 建立 Binding 就是 Channel.queueBind 我想活下去 前面在建立 queue/exchange 的時候都有提到一個概念 durable，它指的是 RabbitMQ 重開之後是否這個 entity 還依然存在 如果要確保訊息是不管怎樣重開機都會存在的話，必須滿足三個條件: 在建立 Queue 時必須設定 durable 為 true 在建立 Exchange 時也必須設定 durable 為 true 在發送訊息的時候，必須設定 Delivery mode 為 2 12345AMQP.BasicProperties props = new AMQP.BasicProperties .Builder() .deliveryMode(2) // DURABLE MESSAGE .build(); 這個 props 在 channel.basicPublish 時放到第三個參數 記得，是發送訊息的時候，別的地方設定是沒用的 無差別 durable 為 true 可以嗎？ 不太好，durable 代表 RabbitMQ 會將資訊記錄在硬碟磁區，相較於存在記憶體中會有效能上的差異 因此，最好是對訊息做個區分: 可以丟失的訊息: 像是廣告的推播之類的 不能丟失的訊息: 像是要刷多少金額 除了分類之外，不能丟失的訊息也建議在發送前也在 client 端備份，以免 RabbitMQ 本身出了什麼差錯 這就會讓整個訊息機制變得更複雜，但為了避免 Single Point of Failure，有時是必須的 可以考慮 REDIS 或甚至是 RDMBS 連處理備份 如果發送訊息到 Exchange 前網路就斷了怎辦？ 可以透過 publisher confirms 來達到訊息送達的確保 古早時期也可以透過 Transaction 來達成，不過有點複雜，而且對效能相當之傷 小結 Exchange 有三種類型: DIRECT/FANOUT/TOPIC Exchange 可搭配 Routing Key 訊息本身是可以挺過重開機的","link":"/2023/02/10/%E3%80%90%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BA-RabbitMQ-4-%E3%80%91-%E8%A8%8A%E6%81%AF%E7%AF%87-2/"},{"title":"【Effective Java 重點摘要】- Item","text":"可考慮優先使用靜態工廠傳統上在建立物件時都是透過 new接著類別定義的建構子會被呼叫並建立實例不過也可以透過靜態工廠達到同樣的效果，為什麼呢？ 優點因為它有名字，而建構子沒有 可以看到如果我們如下初始化 BigInteger 1new BigInteger(int, int ,Random) 上方程式可能是某一個 BigInteger 的建構子的多載 必須記得傳入的參數其順序、型態對應會產出什麼樣的物件 如果改成 1BigInteger.probablePrime() 就能很明確的知道這個方法會回傳的是一個質數的 BigInteger。 個人蠻傾向用這種寫法的，真的清楚很多，甚至是一些需要 clone 的情境也蠻適用的 傳統物件導向的教科書都會透過 Constructor Overloading 應付不同情況的初始化 但靜態工廠方法也許會更好找到要的初始化方式 可以定義 private constructor 搭配 不需總是產出實體 如下方的程式片段: 1Boolean.valueOf(boolean); 它從來不會產生新的物件，而是直接回傳在這個類別第一次被初始化時，就已有建立的兩個成員 TRUE 與 FALSE 這有點類似 GoF 中定義的 Flyweight Pattern，利用共用 Cache 的方式，在初始化大量物件時降低記憶體的使用量 詳細的原始碼可以直接看 JDK 的 Boolean 這個類別的實作(巨人的肩膀) 此外，靜態工廠方法也可用來產 uninstantiatable object 或 singleton，因為它能透過私有化的建構子確保及控制被初始化的物件的數量 這樣的類別可稱作是 instance-controlled 產出來的物件其 equals 實作要特別留意 可回傳方法宣告型態的任何子類別 如此一來，可以回傳非公開的實作類別，例如:在私有內部類別實作某個介面，並以靜態工廠方法回傳 Java 8之前是不能在 interface 定義靜態方法的，都是透過 Types 的型式宣告一個類別定義其中，且該類別是無法被初始化的。e.g. java.util.Collections, java.nio.Files,…等。 Client 端面對的是介面，是個好的寫作習慣 可以依傳入的參數不同回傳不同的子類別 例如: EnumSet，會回傳 RegularEnumSet 或 JumboEnumSet 這兩個子類取的實作都是被隱藏起來的，因此未來若需要再擴充回傳其他子類別也不會影響到原本已經使用 EnumSet 任何程式 這在 EnumSet 原始碼中 noneOf 這方法可以看到 依目前 enum 的數量決定要回傳哪個實作 靜態方法回傳的實際類別在定義方法時不一定已經存在 如同 JDBC 一般的 Service Provider Frameworks， 其組成包含以下幾個要素: Service Interface -&gt; Connection Provider registration API -&gt; DriverManager.registerDriver Service Access API -&gt; DriverManager.getConnection Service Provider Interface -&gt; Driver 其中: Service Interface 就是定義要實作的介面(抽象部份) Provider registration 就是將實作介面的類別組合在抽象功能上。 Service Access API 就是選擇要回傳哪個實作類別的靜態方法。 這就是典型的 **Bridge Pattern**。 缺點沒有public或protected的建構子是無法被繼承的 因為繼承的子類別看不到父類別的建構子，編譯上就不會通過 舉例來說 java.util.Collections 就無法再透過繼承加新功能 不過其實這是因禍得福，因為 OOP 有這麼一條原則，Favor composition over inheritance 過深的繼承樹會使得程式變得極其複雜 用組合在寫單原測試的時候會比較好抽換 Mock 有點難找 因為它有太多種可能的型式，不像建構子在API就只有唯一的地方 所以會有點難分辨究竟要怎樣才能產生實體，不過這個問題可以透過遵循一些命名原則來解決，例: from: 型態轉換，e.g. Date.from(instant) of: 建立集合時用, e.g. EnumSet.of(JACK,QUEEN,KING) getInstance: 確保每次拿到的都是同一個實例 newInstance: 確保每次拿到的都是新的實例 getType: 跟 getInstance 相似，但用在方法被定義在不同的類別時(e.g. Files.getFileStore) newType: 同上，與 newInstance 相似 type: 簡化版的 getType/newType(e.g. Collections.unmodifiableList) 小結 建構子與靜態工廠方法各有千秋 若情況允許可以多以後者為主","link":"/2023/02/14/%E3%80%90Effective-Java-%E9%87%8D%E9%BB%9E%E6%91%98%E8%A6%81%E3%80%91-Item-1/"}],"tags":[{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"Spring Security","slug":"Spring-Security","link":"/tags/Spring-Security/"},{"name":"RabbitMQ","slug":"RabbitMQ","link":"/tags/RabbitMQ/"},{"name":"Effective Java","slug":"Effective-Java","link":"/tags/Effective-Java/"}],"categories":[]}