{"pages":[{"title":"GC's Garbage Collector","text":"Hi, my name is George I´m striving to become a System Architect Loves everything related to Java My Skills JavaScript VanillaJS ES6 TypeScript Angular Tests Jasmine Selenium JUnit Mockito Tooling Webpack Maven Java OO Servlet/JSP Spring Boot CI/CD Jenkins Gitlab Github Actions Docker Kubernetes Main projects Schedule Manager A backend microservice used to manage schedules The objective is to manage all kinds of scheduled tasks","link":"/index.html"},{"title":"關於我","text":"學經歷 大學主修外文，英文為主，日文為輔 碩士主修經濟，擅長個體經濟、計量經濟 半路出家的 Java Programmer 目前為 Full Stack Engineer(自稱) 技術專長Dev(後端) Java SE 的基本 API(OCPJP 7) Spring Framework(Core/Boot/…etc.) MySQL、MSSQL、postgreSQL REDIS MongoDB RabbitMQ、Apache Kafka Dev(前端) Vanilla JS Angular Kendo UI Ops Jenkins 建立完整的 CI/CD 流程 從 commit 到 deploy 均不需額外的功 Docker 將舊系統容器化，建立一致的 Tomcat/Spring boot 用 Dockerfile 建立一致的 docker-compose.yml Kubernetes 建立從 ingress 到 deployment 的 YAML 檔 善用 fast storage/configmap/secret 搭配 Spring Cloud Configuration 中央管理設定檔 透過 Fluentd + Elasticsearch 中央管理日誌","link":"/about/index.html"}],"posts":[{"title":"【深入淺出 Docker(1)】 - Docker 命名由來","text":"平常大家都聽到或稱呼 Docker 習慣了，但您是否知道它的命名由來呢？我相信每一個產品的命名都有它一定的淵源，無論其命名是市場導向，或別有用途，了解它的命名，或許對整體概念能有多一些認識。 歷史 在古早時代，每一種貨物都有其不同的打包方式。亦或是針對它內容物的性質不同，需要特別的環境安置之… 然而在碼頭不可能針對每一項貨物都出專用的工具，或是配置特別的環境處理某些類型的貨物，於是…有人就想出了貨櫃這個打包方式！ 只要你的貨進了貨櫃，那在碼頭的工作人員就不必擔心如何將貨物放置至船上，只要考慮每一個貨櫃的配重即可。 即使是那些需要特殊環境的貨物，只要放進特殊環境的貨櫃即可，再也不用在船上特別提供環境~ 比擬 Docker 與 Container 這個命名的由來，是根據「貨物」透過「貨櫃」的統一置放方式而來 Container 本身除了在 Linux OS 是一個 Process 之外，也暗喻我們所開發的 Application 是以一個「打包好的形式」被部署在各個環境中。 也正因如此， Docker 的 Logo 是隻鯨魚上面載著許多貨櫃，就好比是應用程式被以統一包裝方式(container) 被部署。 小結 不知看了這篇，是否對 docker 本身又更興趣多了點？ 其實容器不只 docker 一種，詳細的以後再寫一篇來談","link":"/2022/01/30/%E3%80%90%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BA%20Docker(1)%E3%80%91%20-%20Docker%20%E5%91%BD%E5%90%8D%E7%94%B1%E4%BE%86/"},{"title":"【深入淺出 Docker(4)】 - docker commit","text":"除了前篇稍微提到的 Dockerfile，還有一種方式可以建立 image如果只是想快速建立一個 snapshot 性質的 image，又不想撰寫完整的 Dockerfile，可以參考這篇的做法~ 說明 再幫各位複習 一下，Image 其實是有很多層 Layer 的，而透過 docker run 建立了 container 後，會多一層可讀寫的 layer。 這個時候如果你針對那個可讀寫的 layer 增加了或減少了內容，都會被記錄在 metadata 中 而如果你想把這些異動的結果再變成 image 交給別人的話，這時候可以透過一個叫作 docker commit 的指令將異動的內容變成一個新的 Docker 實作 假設今天我們透過 ubuntu 的 image 建立了一個 container，指令如下: 1docker run -it --name ubuntu ubuntu /bin/bash 接著我們在 home 底下建立一個目錄與文字檔 1234cd homemkdir testecho \"Hello World\" &gt;&gt; hello.txtls -al 此時如果直接把 container 移除，再透過 ubuntu 的 image 重新建立 container，剛剛新建的目錄與文字檔都不會存在，而這是因為: ubuntu 官方的 image 自然不會有你建立的資訊 可讀寫的那一個 layer 尚未被保存 透過 docker commit 解決的方式如下: 1234567891011121314151617# 先跳出 container 的 bashexit# docker commitdocker commit ubuntu foobar/ubuntu# 檢查本機是否有 image 存在docker images | grep foobar/ubuntu# 移除原本的 containerdocker rm -f ubuntu# 透過新的 image 建立 containerdocker run -it --name ubuntu foobar/ubuntu /bin/bash# 看一下先前建立的資料是否還在ls -al home 此時的 container 概念上可以分成三塊 原本官方 ubuntu 的 image layer(s) 剛透過 docker commit 建立的 layer 啟動 container 時新加上的可讀寫 layer 結論: 針對 container 的一次性異動可以透過這種方式處理 重覆性的操作則建議用 Dockerfile，下篇會詳述","link":"/2022/02/10/%E3%80%90%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BA%20Docker(4)%E3%80%91%20-%20docker%20commit/"},{"title":"【深入淺出 Spring Security(1)】- Spring Security 是什麼？","text":"資安是個 non-functional requirement如果沒人特別要求，或許也不會有人在乎但試想如果銀行的系統出問題了…你的錢就變成別人的錢了呢，是否開始有點同理心了呢？ 什麼是 Spring Security？ 它是一個 Spring Project，詳細內容可參考官方文件 只要掛上 dependency 就可以使用 可透過 XML 或 JavaConfig 設定要防護什麼，怎麼防護 它是 “Application” 層級的防護 它負責處理或支援 Authentication、Authorization 它支援不少風險相關的防護(e.g. OWASP Top Ten Vulnerabilities) 它在 Java Web App 是一個 “Servlet Filter” 它協助處理密碼的管理與加密 Authentication Authentication 指的是確認目前的使用者是誰 在驗證身份的時候可能需要帳密，也可能是透過外部系統(e.g. AD, LDAP, Google/FB/Twitter..) 在驗證前，不能對系統作任何的操作 Authorization Authorization 指的是在確定使用者身份後，區分出這個使用者可存取的權限 比方說可以簡單分 read, write，或是更嚴謹的角色、範疇 OWASP 是 Open Web Application Security Project 的縮寫 上面列出了每一個年度最常被攻擊的風險 很多開源或付費的解決方案 常見的風險如 XSS、SQL Injection、CSRF …等 詳細資訊可參考官方網站 Servlet Filter 只要是寫 Java 後端就必備的知識，會在 Request 進來的時，真正進到 Filter 之前處理 是一種 Chain Of Responsibility Pattern 的變型 Spring Security 正是掛了一整串的 Filter，處理各式各樣的需求如 Authentication、Authorization、Token 解析…等 PasswordEncoder 任何有機密性質的資料都不該被明文儲存(e.g. 使用者密碼) Spring Security 可以透過設定不同的 encoder，用以比對或運算出一組被編碼過的值 為什麼要防護？ 大家都防了你沒防，就好比整條街只有你家大門是開著的 被攻擊的成本遠大於花時間防護 Spring Security 的設定相對輕鬆容易，不會有一堆干涉商業邏輯的程式存在 小結 Spring Security 是用來加在程式上的一道防護 Spring Security 可透過不同段的流程驗證使用者的身份與權限 Spring Security 可幫助防護 OWASP 中提列出的風險","link":"/2022/11/07/%E3%80%90%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BA-Spring-Security-1-%E3%80%91-Spring-Security-%E6%98%AF%E4%BB%80%E9%BA%BC%EF%BC%9F/"},{"title":"【深入淺出 Docker(3)】 - image 是什麼","text":"什麼是 Docker Image？這東西可是 Docker 裡面相當重要的一個要素，沒有它就無法建立 Container，至於為什麼呢？ 組成 正確來說 Image 是 Layers of Image，如果以盤子比喻的話，大概就是一疊盤子 就是你會在資料結構的書上看到的堆疊結構那個樣子，我個人稱之為 Layers of Image 每一一個 Image layer，其內容物為一個含有多個 File 的 Filesystem，透過一個叫作 Union File System 的技術 將每一個層結合再一起，讓你「看起來」是只有一個 Filesystem。 建立 這每一層的 Layer 又是怎麼形成的呢？ 必須要透過一個叫 Dockerfile 的指令腳本來指示建立 Dockerfile 的每一條指令，從 FROM, RUN, COPY, … ENTRYPOINT 等等，都會先建立一個暫時的 container，執行完指令之後，把結果記錄成一個 image layer，而最後最後的結果，其實就是最後一個指令執行完的 image layer 的 ID 以下是一個 Dockerfile 的範例: 123456789101112# nginx state for serving contentFROM --platform=linux/amd64 nginx:alpine# Set working directory to nginx asset directoryWORKDIR /usr/share/nginx/html# Remove default nginx static assetsRUN rm -rf ./*# COPY the result of ng build --prod to WORKDIRCOPY dist/avc-frontend .COPY default.conf /etc/nginx/conf.d/default.conf# Containers run nginx with global directives and daemon offENTRYPOINT [\"nginx\", \"-g\", \"daemon off;\"] 如果想看完整的一個 image 總共有多少 layers，可以透過 docker history，如下: 使用 在我們執行 docker run 的時候，就會在這一個 Layers of image 的頂端建立一個可讀寫的 layer 這意味著了「那一層」之外，所有以下的 Image layer 都是唯讀的，因此這些唯讀的 Image Layer 在不同的 container 間是可以共用的 共用意味著相同內容的 Image layer，就只需要下載一份即可 這也是為什麼有時候在 docker pull 或是 docker build 的時候可以看到 use cache，因為已經有相同內容物的 Image layer 存在了，直接拿來使用就好了。 結論: container 是一個 linux process container 本身所能讀或寫的 filesystem 就是所有唯讀的 image layer 組合起來，再加上它自己可讀寫的那一層 image 是透過 Dockerfile 所寫的腳本透過 docker engine 產出來的","link":"/2022/01/30/%E3%80%90%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BA%20Docker(3)%E3%80%91%20-%20image%20%E6%98%AF%E4%BB%80%E9%BA%BC/"},{"title":"【深入淺出 Docker(2)】- Docker 是什麼","text":"如果有天長官問說「Docker 是什麼？」不知道在座的您會如何回答呢？ What is it？ Docker 是基於 LXC(Linux Container) 的「其中一種」容器建立技術。 建立容器只是其中一種技術，並不代表 Docker 就是容器， 容器還有其他公司有做(舉例: rkt, mesos, rancher… 等等) 特性 它與 Host OS 共享資源 12Host OS 指的是 Docker 被安裝的作業系統有可能是實體機器本身的作業系統，也可能是 VM 上的作業系統 它相對具可攜性，只要機器有裝 Docker Engine，不管在哪運行原則上不會有差異 它相對輕量，一個指令就可以建立，不用像 VM 還要安裝整套的作業系統 它相對容易建立，不用再安裝這個 Framework 那個 掛那個 dll，設定環境變數… 組成 Docker Engine =&gt; 又分作實際做事的 Docker Deamon 與跟 Daemon 互動的 Docker Client Docker hub =&gt; 負責存放 Docker Image 的一個 Registry Linux vs. Others 一般在 Linux 的任何一個 Distribution 上安裝的都是原生的 Docker Mac / Windows (Pro)/ Win 10 + WSL2 上安裝的，中間其實都偷偷墊了一層 VM，也因為如此，測試機才會是直接裝 Docker，而本機開發也可以用安裝包處理 不論在哪種 OS 下，面對 Docker Engine 的操作模式都會是一樣的！ 總結 容器就是應用程式與其所有相依套件於一體的 Linux Process 前面提到的 Image 是什麼？ 詳細的以後再寫一篇來談","link":"/2022/01/30/%E3%80%90%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BA%20Docker(2)%E3%80%91-%20Docker%20%E6%98%AF%E4%BB%80%E9%BA%BC/"},{"title":"【深入淺出 Spring Security(2)】- Hello World","text":"如同平時學程式語言一般，我們也從 Hello World 開始吧！這篇我們會從無到有，建立一個簡單的 endpoint，接著再加入 Security 的元素，並簡單說明框架幫忙做了什麼！ 「無」 Spring Security 版本首先就來一個不包含 Spring Security 的 project 建立一個 Project 建立的方式就參照各大網站的教學建立一個 Maven Project 建立的是 Spring Boot Application，其中 starter 的部份請選擇 Spring-Web，才能處理基本的請求／回應 此時的 pom.xml 中的 dependency 大致上長這樣 123456789101112 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 建立一個 Endpoint 首先在 base package 建立一個 HelloController 接著開出一個方法，回傳的型態是 String 最後在實作的部份回傳 “Hello World” 程式碼大致上會如下: 12345678910111213package org.dream.helloworld;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloWorldController { @GetMapping(value = \"hello\") public String hello() { return \"Hello World\"; }} @RestController 隱含著 @ResponseBody，代表回傳的結果會是透過預設的 HttpMessageConverter(Jackson) 處理 @GetMapping 代表這個方法接受 HTTP GET 驗證功能 首先啟動你的 Spring Boot Application 接著打開瀏覽器，並在網址列輸入 localhost:8080/hello，最後按下 enter 就會在瀏覽器看到如下的畫面囉 「有」Spring Security 版本接著就替我們的程式加上防護吧！ 補上 dependency 先把先前啟動的服務停掉(除非有掛上 dev-tools) 在 pom.xml 的 dependencies 中間加上以下 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 這個是 spring boot 針對 security 提供的 starter 有興趣可以展開它的內容看看大致上包含了什麼東西 接著再啟動一次服務，就會在 console 看到如下的畫面 紅框框起來的部份，是框架產出的密碼，可以先複製到剪貼簿上 紅框下方可以看到服務自動被掛上了 DefaultSecurityFilterChain 最後再重試造訪一次 localhost:8080/hello 咦？需要登入了！ 此時輸入帳號 user，密碼為前面複製起來的值，就可以看到如同先前尚未掛上 Spring Security 時的結果 註1: 如果輸錯帳密就會看到以下畫面 註2: 可以嘗試一下以如用 curl 會是什麼結果 Spring Security 簡述Spring Security 的流程 首先請求進到服務，被 AuthenticationFilter 攔截 這個 Filter 跟 Java EE 中的 ServletFilter 是近乎相同的概念 這個 Filter 預設會解析請求的 Header 中所包含的使用者與密碼當作 Token，這也是為什麼用帳號密碼可以登入 接著「驗證」被交給 AuthenticationManager 處理 AuthenticationManager 把驗證委派給一至多個 AuthenticationProvider 處理 常見的實作有 Ldap、Dao、OAuth2 …等 也可以自定義！ AuthenticationProvider 把找人的部份交給了 UserDetailsService，並把密碼屏蔽的部份交給了 PasswordEncoder UserDetailsService 可以自行實作，或用 Spring Security 內建提供的，如同範例用到的就叫 InMemoryUserDetailsService(後續會再提) PasswordEncoder 常見的有 BCrypt、SCrypt、NoOp …等內建的 以上的結果會存放到 SecurityContext 可以把它當作一個存放登入後的資訊的點 這是一個 In-Memory 且 ThreadLocal 的值 從系統角度看它做了什麼？ 實作 UserDetailsService 並建立一個 user，且設定帳密 設定 HTTP Basic Authentication 防護「所有的」 endpoint，需 Authenticate 過才能存取 很多其它的元件被設定了預設值(目前還沒看到) 這樣就好了？ 當時不是，雖然目前系統已加上了防護，但仍有幾個問題 帳密只有一組(如果別人也要使用服務？) 密碼印在 console(這風險還不夠大嗎？) 所有的 endpoint 都被防護 驗證的方式並非自行設定的 .. …(略) 除了以上提到的部份之外，請留意這就是 Convention over Configuration 什麼都不用做，或是照一些慣例設定就可以達到很複雜的功能的基本設定 但這不代表真的所有系統都完全不用再設定了 小結 從此篇可以了解到，掛上 dependency，spring security 做了什麼預設的處理 下一篇開始將依 Spring Security 各個環節提供自訂的實作","link":"/2022/11/09/%E3%80%90%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BA-Spring-Security-2-%E3%80%91-Hello-World/"}],"tags":[{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"Spring Security","slug":"Spring-Security","link":"/tags/Spring-Security/"}],"categories":[]}